---
description: 원시 타입과 객체 타입을 비교하고 구분하는 이유와 차이점을 알아봅시다.
---

# 원시 타입 vs 객체 타입
두 타입은 크게 세 가지 측면에서 다르다. <br>
1. 원시 타입은 **변경 불가능한 값**이고 객체 타입은 **변경 가능한 값**이다.
2. 원시 값을 변수(메모리 공간)에 할당하면 값이 저장되지만 객체를 변수(메모리 공간)에 할당하면 참조 값이 저장된다.
3. 원시 값을 갖는 변수를 다른 변수에 할당하면 **원본의 원시 값이 복사되어 전달**된다. 이를 **값에 의한 전달(pass by value)**라고 한다. <br>
반면에 객체를 가르키는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달**된다. 이를 **참조에 의한 전달(pass by reference)**라고 한다. <br>

# 변경 불가능한 값이다?
```
var num = 1;
num = 2;
console.log(num); // 2
```
분명히 변수 `num`의 타입은 원시 타입인 `Number`이다. 하지만 값은 1에서 2로 변경된다. 그렇다면 무엇이 변경 불가능 하다는 것일까? <br>
사실 위 말엔 오류가 있다. **값**이 변경되는게 아니라, **변수(식별자)**가 바뀌는 것이기 때문이다. <br>
우리가 변수라고 부르는 것은 메모리 공간을 가르키는 **식별자**이며 값이라 부르는 것은 메모리 공간안에 있는 **표현식을 평가해 생성된 결과**를 말한다. <br>
이전 변수 챕터에서도 말하였지만 변수에 값이 할당 될 때는 기존 값이 있는 공간에 덮어 씌우는게 아니라 새로운 공간에 값을 할당하고 식별자를 변경하는 것이다. <br>
나 또한 변수 챕터 때는 '왜 이렇게 할당될까?' 라고 생각하였지만 그 이유는 값이 **원시 타입**이었기 때문이었다. <br>
**원시 타입**은 이처럼 변하지 않는다. 위 예제에서도 변하는 것은 단순히 **변수(식별자)**이다. 그리고 만약 식별자조차 변경하고 싶지 않다면 (첫 할당을 제외하고) `const(상수)` 키워드를 사용하는 것이다. <br>

변경이 불가능하다는 특성 원시 타입의 특성은 변수에 원시 타입을 할당 했을 때 변수를 재할당하지 않고서는 값이 변하지 않다는 것을 의미하고, 이는 값의 신뢰성을 높이는 장점이 있다. <br>

# 문자열과 불변성
문자열 타입은 다른 원시 값과 비교했을 때 독특한 특징이 있다. <br>
문자열의 경우 몇 개의 문자로 이뤄졌느냐에 따라 메모리 공간의 크기가 결정된다. 숫자 타입 같은 경우는 1이나 100000이나 8바이트의 메모리 공간이 필요하지만, 문자열은 단순하게 계산했을 때 문자가 한 개로 이뤄졌을때는 2바이트, 10개로 이뤄졌을때는 20바이트의 메모리 공간이 필요하다. <br>

그리고 문자열은 **유사 배열 객체**이라서 배열처럼 인덱스를 사용해 각 문자에 접근할 수도 있다. <br>
```
var str = 'string';

str[0] = 'S';

console.log(str); // 'string' 불변!
```
위 예제를 보면 `str[0]` 인덱서를 통해 첫 문자인 `'s'`에 접근하고 있다. 그 후 `'S'`를 할당한다. <br>
그러나 유사 배열 객체라서 접근할 수 있었을 뿐! 변경은 할 수 없다. 문자열은 **원시 타입**이기 때문이다. <br>
주의할 점은 변경은 되지 않지만 에러는 발생하지 않는다. 따라서 원시 타입 값에 접근할 수 있다고 해서 변경하려는 오류를 범해선 안된다. <br>

# 값에 의한 전달
```
var score = 80;
var copy = score;

console.log(score === copy); // true 둘 다 80이다.

score = 100;

console.log(copy); // ?
```
위 예제에서는 원시 값이 담긴 `score`를 `copy`에 할당한다. 이 때 `score`의 메모리 공간에 있는 값이 복사되어 `copy`에 할당되는데 이를 **값에 의한 전달**이라고 한다. <br>
따라서 `copy`에는 `80`이 할당된다. 그렇다면 이 후 `score`에 `100`을 재할당하면 `copy`의 값은 무엇일까? <br>
답은 `80`이다. 그 이유는 둘의 값은 같지만 **식별자가 가르키는 메모리 공간은 다르기 떄문**이다. <br>

# 객체
객체는 프로퍼티 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티 값에 제한도 없다. <br>
따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다. <br>
이처럼 객체는 복잡한 자료구조이므로 원시 값과 다른 방식으로 동작하도록 설계되어 있다. <br>

> 자**바스크립트 객체의 관리 방식** <br>
자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 **해시 테이블(연관 배열이라고 부르기도 한다.)**이라고 생각할 수 있다. <br>
대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다. <br>
자바, C++ 같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스로 객체(인스턴스)를 생성한다. <br>
따라서 정해진 프로퍼티와 메서드로 객체를 생성한다. 객체가 생성된 이후에는 프로퍼티를 삭제하거나 추가할 수 없다. <br>
이에 비해 자바스크립트는 추가, 삭제 모두 가능하고 프로퍼티, 메소드도 정해져 있지 않다. 이는 매우 편리하지만 성능 면에서는 비효율적이다. <br>
때문에 V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 **동적 탐색** 대신 **히든 클래스**라는 방식을 사용해 C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장한다. <br>
**관련 링크** <br>
> - https://engineering.linecorp.com/ko/blog/v8-hidden-class/
> - https://meetup.toast.com/posts/78

<br>

# 변경 가능한 값
**객체(참조) 타입의 값, 즉 객체는 변경 가능한 값**이다. <br>
객체에 값을 할당하면 메모리 공간에 **참조 값**이 저장되는데 **참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체**이다.

# 왜 이럴까?
그렇다면 왜 원시 타입과 객체(참조) 타입은 메모리 공간에 다른 방식으로 값을 저장하는 것일까? <br>
앞서 이야기 하였듯 객체 타입은 원시 타입과는 다르게 복잡한 자료구조이다. 값이 엄청 클 수도 있고, 프로퍼티의 값으로 객체가 들어 있을 수도 있다. 때문에 원시 타입처럼 할당 시 메모리 공간에 값을 카피해서 생성하는 것은 비용이 많이 든다. <br>
때문에 객체는 메모리 공간에 생성된 객체의 주소 값을 저장하며 변경 가능한 값으로 설계된 것이다. <br>
하지만 이 방식엔 문제가 존재한다. 그건 **여러 개의 식별자가 하나의 객체를 공유할 수 있다**는 것이다. <br>

> **얕은복사와 깊은 복사** <br>
객체를 프로퍼티 값으로 갖는 객체의 경우 **얕은 복사는 한 단계까지만 복사하는 것**을 말하고, **깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것**을 말한다. <br>
>```
> const obj = { x: { y: 1 } };
>
> // 얕은 복사
> const shallowCopy = { ...obj };
> console.log(shallowCopy === obj); // false
> console.log(shallowCopy.x === obj.x); // true
>
> // 깊은 복사 (책에선 'lodash'의 cloneDeep을 사용하였지만 여기선 생략하였습니다.)
> const deepwCopy = { ...obj };
> console.log(deepwCopy === obj); // false
> console.log(deepwCopy.x === obj.x); // false
>```
> 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다. 따라서 원본 객체와 일치 연산을 하면 `false`가 나온다. <br>
하지만 얕은 복사는 프로퍼티 값이 객체일 경우 한 단계까지만 복사하고 그 이후론 참조 값을 복사한다. <br>
때문에 `shallowCopy.x === obj.x` 값이 `true` 인 것이다. <br>
참고로 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 **깊은 복사** 객체를 할당한 변수를 다른 변수에 할당하는 것을 **얕은 복사**라고 하기도 한다. (동작이 같기 때문에) <br>

# 참조에 의한 전달
지금까지 객체의 할당 과정에서 동작하는 방식을 **참조에 의한 전달**이라고 했다.<br>
하지만 사실 자바스크립트에서 **참조에 의한 전달**은 존재하지 않는다. 왜냐하면 메모리 공간, 즉 변수에 저장된 값이 값이냐 참조 값이냐에 따라서 **값에 의한 전달**, **참조에 의한 전달**로 말하기 떄문이다. <br>
하지만 따로 공식적인 용어는 없으므로 용어는 그대로 사용하되, 다른 프로그래밍 언어에서의 **참조에 의한 전달**과는 의미가 정확히 일치하지 않는다는 점만 주의하자. <br>

