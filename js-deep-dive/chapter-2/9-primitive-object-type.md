---
description: 원시 타입과 객체 타입을 비교하고 구분하는 이유와 차이점을 알아봅시다.
---

# 원시 타입 vs 객체 타입
두 타입은 크게 세 가지 측면에서 다르다. <br>
1. 원시 타입은 **변경 불가능한 값**이고 객체 타입은 **변경 가능한 값**이다.
2. 원시 값을 변수(메모리 공간)에 할당하면 값이 저장되지만 객체를 변수(메모리 공간)에 할당하면 참조 값이 저장된다.
3. 원시 값을 갖는 변수를 다른 변수에 할당하면 **원본의 원시 값이 복사되어 전달**된다. 이를 **값에 의한 전달(pass by value)**라고 한다. <br>
반면에 객체를 가르키는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달**된다. 이를 **참조에 의한 전달(pass by reference)**라고 한다. <br>

# 변경 불가능한 값이다?
```
var num = 1;
num = 2;
console.log(num); // 2
```
분명히 변수 `num`의 타입은 원시 타입인 `Number`이다. 하지만 값은 1에서 2로 변경된다. 그렇다면 무엇이 변경 불가능 하다는 것일까? <br>
사실 위 말엔 오류가 있다. **값**이 변경되는게 아니라, **변수(식별자)**가 바뀌는 것이기 때문이다. <br>
우리가 변수라고 부르는 것은 메모리 공간을 가르키는 **식별자**이며 값이라 부르는 것은 메모리 공간안에 있는 **표현식을 평가해 생성된 결과**를 말한다. <br>
이전 변수 챕터에서도 말하였지만 변수에 값이 할당 될 때는 기존 값이 있는 공간에 덮어 씌우는게 아니라 새로운 공간에 값을 할당하고 식별자를 변경하는 것이다. <br>
나 또한 변수 챕터 때는 '왜 이렇게 할당될까?' 라고 생각하였지만 그 이유는 값이 **원시 타입**이었기 때문이었다. <br>
**원시 타입**은 이처럼 변하지 않는다. 위 예제에서도 변하는 것은 단순히 **변수(식별자)**이다. 그리고 만약 식별자조차 변경하고 싶지 않다면 (첫 할당을 제외하고) `const(상수)` 키워드를 사용하는 것이다. <br>

변경이 불가능하다는 특성 원시 타입의 특성은 변수에 원시 타입을 할당 했을 때 변수를 재할당하지 않고서는 값이 변하지 않다는 것을 의미하고, 이는 값의 신뢰성을 높이는 장점이 있다. <br>

# 문자열과 불변성
문자열 타입은 다른 원시 값과 비교했을 때 독특한 특징이 있다. <br>
문자열의 경우 몇 개의 문자로 이뤄졌느냐에 따라 메모리 공간의 크기가 결정된다. 숫자 타입 같은 경우는 1이나 100000이나 8바이트의 메모리 공간이 필요하지만, 문자열은 단순하게 계산했을 때 문자가 한 개로 이뤄졌을때는 2바이트, 10개로 이뤄졌을때는 20바이트의 메모리 공간이 필요하다. <br>

그리고 문자열은 **유사 배열 객체**이라서 배열처럼 인덱스를 사용해 각 문자에 접근할 수도 있다. <br>
```
var str = 'string';

str[0] = 'S';

console.log(str); // 'string' 불변!
```
위 예제를 보면 `str[0]` 인덱서를 통해 첫 문자인 `'s'`에 접근하고 있다. 그 후 `'S'`를 할당한다. <br>
그러나 유사 배열 객체라서 접근할 수 있었을 뿐! 변경은 할 수 없다. 문자열은 **원시 타입**이기 때문이다. <br>
주의할 점은 변경은 되지 않지만 에러는 발생하지 않는다. 따라서 원시 타입 값에 접근할 수 있다고 해서 변경하려는 오류를 범해선 안된다. <br>

# 값에 의한 전달
```
var score = 80;
var copy = score;

console.log(score === copy); // true 둘 다 80이다.

score = 100;

console.log(copy); // ?
```
위 예제에서는 원시 값이 담긴 `score`를 `copy`에 할당한다. 이 때 `score`의 메모리 공간에 있는 값이 복사되어 `copy`에 할당되는데 이를 **값에 의한 전달**이라고 한다. <br>
따라서 `copy`에는 `80`이 할당된다. 그렇다면 이 후 `score`에 `100`을 재할당하면 `copy`의 값은 무엇일까? <br>
답은 `80`이다. 그 이유는 둘의 값은 같지만 **식별자가 가르키는 메모리 공간은 다르기 떄문**이다. <br>


