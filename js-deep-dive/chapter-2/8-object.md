---
description: 객체에 대해 알아봅시다.
---

# 객체
자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 구성하는 거의 모든 것이 객체다. <br>
원시 값을 제외한 나머지(함수, 배열, 정규 표현식 등)은 모두 객체다. <br>

원시 타입은 단 하나의 값만 나타내며, 변경할 수 없는 값(immutable value)이지만 객체는 여러 값을 가질 수 있으먀 변경 가능한 값(mutable value)이다. <br>

자바스크립트에서는 사용할수 있는 모든 값은 프로퍼티가 될 수 있다. 자바스크립트의 함수는 일급 객체(18 챕터에서 등장한다) 이므로 값으로 취급할 수 있고 따라서 함수도 프로퍼티가 될 수 있다. <br>
그렇게 프로퍼티가 된 함수는 일반 함수와 구별하기 위해 **메서드**라고 부른다.

이처럼 객체는 객체의 상태를 나타내는 값인 **프로퍼티**와 **프로퍼티**를 참조하고 조작할 수 있는 동작(behavior)인 **메서드**로 구성된 집합체이다. <br>
때문에 객체는 상태와 상태를 조작하는 동작을 하나의 단위로 구조화 시킬 수 있어 유용하다. <br>

# 객체 생성
C++나 자바 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다. <br>

> **인스턴스** <br>
인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체를 뜻한다. <br>
객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다. <br>
여기서 클래스는 인스턴스를 만드는 템플릿 역할, 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어다. <br>

자바스크립트는 프로토타입 기반 객체지향 언어로서 다양한 객체 생성 방법을 지원한다. <br>
- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

이 중 가장 일반적이고 간단한 방법은 **객체 리터럴**이다. **객체 리터럴**은 {...} 내에 0개 이상의 프로퍼티를 정의한다. <br>
그럼 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성한다. <br>

객체 리터럴은 코드 블록을 의미하지 않는다. 둘의 차이점은 객체 리터럴은 세미콜론을 붙이고 코드 블록은 안붙인다는 것이다. <br>

# 프로퍼티
**객체는 프로퍼티의 집합. 프로퍼티는 키와 값으로 구성된다.**

프로퍼티의 키로는 **빈 문자열을 포함하는 모든 문자열 또는 심벌 값**을 사용할 수 있고, 프로퍼티의 값으로는 **자바스크립트에서 사용할 수 있는 모든 값**을 사용할 수 있다. <br>
프로퍼티 키는 식별자 역할을 하지만 반드시 식별자 네이밍을 사용해야 하는 것은 아니다. <br>
다만, 식별자 값을 `'...' 또는 "..."`로 묶어서 사용하지 않으려면 식별자 네이밍 규칙을 따라야만 한다. <br>(그 외에도 식별자 네이밍 규칙을 따르지 않으면 귀찮은 일이 많다고 하니 최대한 따르도록 하자) <br>

프로퍼티에 문자열, 심벌 값을 제외한 다른 타입의 값을 넣으면 암묵적 타입 변환을 통해 문자열로 변환된다. <br>

이미 존재하는 키 값을 중복 선언하면 덮어 씌워지지만 에러가 발생하지 않으므로 조심해야한다.
```
var foo = {
    name: 'Lee',
    name: 'Kim'
};

console.log(foo.name); // 'Kim'
```

# 프로퍼티 갱신, 생성, 삭제
이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신되며 만약 존재하지 않는 프로퍼티라면 동적 생성 된다. <br>
프로퍼티를 삭제하고 싶다면 `delete` 연산자를 사용하면 되는데 `delete` 연산자의 피연산자는 꼭 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 아닐 경우 제대로 동작(프로퍼티 삭제) 되지 않지만 **에러는 반환하지 않음**으로 주의해야한다. <br>

# ES6에서 추가된 객체 리터럴 확장 기능

1. 프로퍼티 축약 표현
프로퍼티 키와 값이 동일한 네임일 때 프로퍼티 키를 생략할 수 있다. <br>
```
// ES5
var obj = {
    x: x,
    y: y 
};

// ES6
var obj = { x, y }; 👍 깔끔!
```

2. 계산된 프로퍼티 이름
ES5에서도 `대괄호[...]` 안에 문자열 또는 문자열로 반환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있었다. <br>
단, **객체 리터럴 외부에서만 가능했다.** <br>

그래서 ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키 값을 동적 생성 할 수 있다. <br>

3. 메서드 축약 표현
ES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다. <br>
```
// ES5
var obj = {
    foo: function() {
        console.log('ES5');
    }
}

// ES6
var obj = {
    foo() {
        console.log('ES6');
    }
}
```
**메서드 축약 표현**으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다.<br>
(이에 대한 내용은 후에 나온다고 한다. ...뭔데 궁금하게 말 안해주는걸까)






