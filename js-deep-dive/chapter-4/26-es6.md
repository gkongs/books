---
description: ES6 함수의 추가 기능을 알아봅시다.
---

# 함수의 구분
ES6 이전까지 자바스크립트의 함수는 별다른 구분 없이 다양한 목적으로 사용되었다. 자바스크립트의 함수는 일반적인 함수로서 호출할 수도 있고, new 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 생성자 함수로서 호출할 수도 있으며, 객체에 바인딩되어 메서드로서 호출할 수도 있다. <br>
이는 언뜻 보면 편리한 것 같지만 실수를 유발시킬 수 없으며 성능 면에서도 손해다. <br>
```
var foo = function () {
    return 1;
}

// 일반적인 함수로서 호출
foo(); // 1

// 생성자 함수로서 호출
new foo(); // foo {}

// 메서드로서 호출
var obj = { foo: foo };
obj.foo(); // 1
```
이처럼 ES6 이전의 모든 함수는 callable이면서 constructor다.

> **호출할 수 있는 함수 객체를 callable이라 하며, 인스턴스를 생성할 수 있는 함수 객체를 constructor, 인스턴스를 생성할 수 없는 함수 객체를 non-constructor라고 부른다.**

ES6 이전의 모든 함수는 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성하여 실수를 유발하고, 성능면에서도 좋지 않았다. <br>

> **ES6 함수의 구분** <br>
> - 일반 함수 - constructor, prototype, arguments 
> - 메서드 - super, arguments
> - 화살표 함수 - x <br>
> 일반 함수는 constructor 이지만 메서드와 화살표 함수는 non-constructor이다.

# 메서드
ES6 사양에서 메서드는 **축약 표현으로 정의된 함수만을 의미**한다.
<br>
```
const obj = {
    foo() { return this.x; }, // 메서드
    bar: function() { return this.x; } // 일반함수
}
```
ES6 사양에서 정의한 메서드(이하 ES6 메서드)는 인스턴스를 생성할 수 앖는 non-constructor다. 따라서 ES6 메서드는 생성자 함수로서 호출할 수 없다. <br>

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 가진다. <br> super 참조는 내부 슬롯 `[[HomeObject]]`를 사용하여 수퍼클래스의 메서드를 참조하므로 내부 슬롯 `[[HomeObject]]`를 갖는 ES6 메서드는 super 키워드를 사용할 수 있다. <br>

이처럼 ES6 메서드는 본연의 기능을 추가하고 의미적으로 맞지 않는 생성자 기능은 제거하여 메서드를 정의할 때 익명 함수 표현식을 할당하는 ES6 이전 방식을 개선 했으므로 이전 방식은 사용하지 않는 것이 좋다. <br>

# 화살표 함수
화살표 함수는 간략하게 함수를 정의할 수 있는데 표현만이 아니라 내부 동작도 기존의 함수보다 간략하다. <br>
특히 화살표 함수는 내부 this가 전역객체를 가르키는 문제를 해결하기 위한 대안으로 유용하다. <br>

함수 몸체는 표현식인 문이라면 { }를 제외하고 사용하면 암묵적으로 반환되는 특징이 있다. <br>
```
const arrow = (x) => x * 1;
```

> 객체 리터럴을 반환할 때는 소괄호 () 로 감싸야한다. 아니면 객체 리터럴의 중괄호를 함수 몸체를 감싸는 중괄호로 인식한다.

화살표 함수도 IIFE(즉시 실행 함수)로 사용할 수 있다. <br>
```
const person = (name => ({
    sayHi() { return `${name} Hi`; }
}))('Lee'); // Lee Hi
```

화살표 함수도 일급 객체이므로 고차 함수에 인수로 전달할 수 있으며, 일반적인 함수보다 가독성이 좋다. <br>
```
[1, 2, 3].map(function(v) => {
    return v * 2;
});

// arrow
[1, 2, 3].map(v => v * 2);
```
이처럼 화살표 함수는 콜백 함수로서 정의할 때 유용하다. 화살표 함수는 표현도 간편하지만, 일반 함수의 기능을 간략화했으며 this도 편리하게 설계 되었다. <br>

### 일반 함수 vs 화살표 함수

1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.
- 화살표 함수는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
2. 중복된 매개변수 이름을 선언할 수 없다.
- (일반 함수도 strict mode에서는 선언할 수 없다)
3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.
- 따라서 화살표 함수 내부에서 this, arguments, super, new.target을 참조하면 상위 스코프의 this, arguments, super, new.target을 참조한다. <br>

### this
this에 바인딩할 객체는 함수를 호출할 때 어떻게 호출되었는지에 따라 동적으로 결정된다. <br>
일반 함수로서 호출되는 모든 함수 내부의 this는 전역 객체를 가리킨다. 그런데 클래스 내부의 모든 코드에는 strict mode가 암묵적으로 적용되어 일반 함수로 호출된 모든 함수 내부의 this에는 undefined가 바인딩 된다.

이 때 발생하는 문제가 콜백 함수 내부의 this 문제다. 이 문제는 콜백 함수의 this와 외부 함수의 this가 서로 다른 값을 가리키고 있어 TypeError가 발생하는 문제다. <br>

화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. <br>
이를 lexical this라 한다. 이는 마치 렉시컬 스코프와 같이 **화살표 함수의 this가 함수가 정의된 위치에 의해 결정된다는 것을 의미**한다. <br>

화살표 함수는 this를 갖지 않기 때문에 bind, apply, call등을 사용해도 this를 교채할 수 없다. <br>

메서드를 화살표 함수로 정의하면 메서드를 호출한 객체가 아닌 상위 함수의 this를 가르키기 때문에 사용하지 않는 것이 바람직하다. 메서드를 정의할 때는 ES6 메서드 축약 표현을 사용하는 것이 좋다.<br>
(프로토타입 객체의 프로퍼티에 화살표 함수를 할당하는 경우도 동일한 문제가 발생한다.) <br>

클래스 필드 정의 제안을 통해 클래스 필드에 화살표 함수를 할당할 수도 있지만, 이 경우 화살표 함수를 할당한 필드는 인스턴스를 가르키고 따라서 프로토타입 메서드가 아니라 인스턴스 메서드가 되므로 메서드를 정의할 때는 축약 표현을 사용하는 것이 좋다. <br>

### super
화살표 함수에는 super가 없기에 this와 마찬가지로 상위의 super를 참조한다. <br>

### arguments
arguments는 가변 인자 함수를 구현할 때 유용하지만 화살표 함수에는 바인딩된 argumnets가 없다. 따라서 가변 인자를 구현할 때에는 반드시 **Rest**를 사용해야 한다. <br>