---
description: 클로저에 대해 알아봅시다.
---

# 클로저
MDN에서는 클로저를 당므과 같이 정의하고 있다. **클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.** <br>
정의만으로는 알기 어려운 개념이기에, 자바스크립트의 동작 방식과 연관지어 이해하는 것이 좋다. <br>

# 렉시컬 스코프
자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정하는데 이를 렉시컬 스코프(정적 스코프)라고 한다. <br>

위 설명처럼 자바스크립트에서의 스코프는 실행 컨텍스트의 렉시컬 환경이다. 그리고 이 렉시컬 환경은 자신의 **외부 렉시컬 환경에 대한 참조**를 통해 상위 렉시컬 환경과 연결되는데 이게 바로 **스코프 체인**이다. <br>

그래서 위 개념을 적용해 다시 한 번 렉시컬 스코프를 정의해보면 다음과 같다.
<br>
렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다. 이것이 바로 렉시컬 스코프이다.<br>

# 함수 객체의 내부 슬롯 [[Environment]]
함수가 정의된 환경(위치)과 호출되는 환경(위치)은 다를 수 있다. 따라서 렉시컬 스코프가 가능하려면 함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경인 상위 스코프를 기억해야 하며, 함수는 자신의 **내부 슬롯**에 자신이 정의된 환경인 상위 스코프의 참조를 저장한다. <br>
함수 객체는 내부 슬롯 `[[Environment]]`에 저장한 렉시컬 환경의 참조, 상위 스코프를 자신이 존재하는 한 기억한다. <br>

# 클로저와 렉시컬 환경
```
function outer() {
    const x = 10;
    const inner = function () { console.log(x); }
    return inner;
}

const innerFunc = outer();
innerFunc(); // 10
```
위 예제에서 `outer`의 내부 함수인 inner를 반환하고 생명 주기를 마감한다. 따라서 지역 변수인 x도 같이 생을 마감한다. <br>
하지만 `innerFunc()`을 호출했을 때 콘솔에는 10이라는 값이 적힌다. 이처럼 **외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있으며, 이러한 중첩 함수를 클로저라고 부른다.** <br>

자바스크립트는 가비지 컬렉터에 의해 사용하지 않는 메모리 즉, 참조되지 않는 메모리를 정리하는데, 위의 경우 클로저가 외부 함수의 변수를 참조하고 있으므로 외부 함수의 변수인 `x`가 소멸되지 않는 것이다. <br>

자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로는 모든 함수는 클로저이지만 **중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.** <br>

클로저에 의해 참조되는 상위 스코프의 변수를 **자유 변수**라고 하며 **클로저란 함수가 자유 변수에 대해 닫혀있다**라는 의미이다. 이를 알기 쉽게 의역해보자면 "자유 변수에 묶여있는 함수"라고 할 수 있다. <br>

클로저는 상위 스코프를 기억해야하므로 불필요한 메모리를 저장한다고 생각할 수 있지만, 자바스크립트 엔진의 최적화로 인해 클로저가 참조하고 있지 않은 식별자는 기억하지 않는다. <br>

# 클로저의 활용
**클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 다시 말해서 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.** <br>

```
let num = 0;

const increase = function () {
    return ++num;
}

console.log(increase()); // 1
```
위 예제에서의 문제점은 increase 라는 함수를 통해서만 num이라는 변수의 값이 증가해야 하지만 num은 increase가 아니더라도 변경될 수 있다는 것이다. <br>

따라서 num을 좀 더 작은 영역(스코프)에 선언할 필요가 있다. 그렇다면 increase 함수 내부의 지역 변수로 넣으면 될까?
```
const increase() {
    let num = 0;
    return ++num;
}

console.log(increase()); // 1
console.log(increase()); // 1
```
이젠 increase 함수를 통해서만 num 변수값을 증가 시킬 수 있다. 하지만 선언후 값을 증가시키는 로직이 같이 존재하기 때문에 원하는대로 호출시 1씩 증가되지 않는다. 이럴때 우린 클로저를 활용할 수 있다. <br>

```
const increase = (function () {
    let num = 0;
    reteurn function() {
        return ++num;
    }
})

console.log(increase()); // 1
console.log(increase()); // 2
```
위 예제에선 클로저를 통해 num 변수를 `private` 변수로 설정하고 외부로부터 안전하게 은닉하는 동시에 상태를 변경 시키는 로직을 작성할 수 있다. <br>
이처럼 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다. <br>

# 캡슐화와 정보 은닉
캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 한다. <br>
정보 은닉은 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 보호하고, 객체 간의 상호 의존성, 즉 **결합도**를 낮추는 효과가 있다. <br>
대부분의 객체 지향 프로그래밍 언어는 접근 제한자가 있지만 자바스크립트에는 접근 제한자가 따로 존재하지 않는다. <br>
자바스크립트 객체의 모든 프로퍼티와 메서드는 기본적으로 외부에 공개되어 있다. 즉, 객체의 모든 프로퍼티와 메서드는 기본적으로 public이라고 할 수 있다. <br>

> 자바스크립트의 접근 제한자 <br>
자바스크립트에는 본래 접근 제한자가 존재하지 않았지만, ES6에 클래스가 나오고, ES2022에는 #을 통해 private를 선언할 수 있도록 추가되었다.
또한 typescript를 사용하여 접근 제한자를 사용할 수 있다. <br>

```
function Person(name, age) {
    this.name = name // public
    let _age = age;

    // 인스턴스 메서드
    this.sayHi = function () {
        console.log('Hi');
    }
}
const me = new Person('Lee', 20);
console.log(me.name); // Lee
console.log(me._age); // undefined
```
위 예제에서 name은 공개된 public 변수이기 때문에 외부에서 참조하거나 변경 불가능하지만 _age는 비공개 private 변수이기 때문에 외부에서 참조하거나 변경할 수 없다. <br>

sayHi는 인스턴스 메서드이고 어떤 Person 인스턴스라고 똑같은 동작을 수행한다. 때문에 Person 내부 함수로 두면 코드 중복이 생긴다. 따라서 중복 생성을 방지해보자. <br>

```
// 프로토타입 메서드
Person.prototype.sayHi = function() {
    console.log(`Hi ${_age}!`);
};
```
이렇게 프로토타입 메서드를 사용하면 중복을 막을 수 있다. 하지만 위 예제는 _age를 참조하지 못하는 오류가 발생한다. 따라서 앞서 나왔던 클로저를 사용하여 _age를 참조할 수 있도록 변경해보자 <br>

```
const Person = (function() {
    let _age = 0;

    // 생성자 함수
    function Person(name, age) {
        this.name = name; // public
        _age = age;
    }

    // 프로토타입 메서드
    Person.prototype.sayHi = function () {
        console.log(`Hi ${_age}!`);
    }

    // 생성자 함수를 반환
    return Person;
}());
```
위 패턴을 사용하면 자바스크립트에서도 정보 은닉이 가능한 것처럼 보인다. <br>
하지만 위 코드도 문제가 있다. Person 생성자 함수가 여러 개의 인스턴스를 생성할 경우 다음과 같이 _age 변수의 상태가 유지되지 않는다. <br>

```
const me = new Person('Lee', 20);
me.sayHi();

const you = new Person('Kim', 30);
you.sayHi();

me.sayHi(); // _age 값이 30 으로 변경된다.
```
이는 Person.prototype.sayHi 메서드가 단 한 번 생성되는 클로저이기 때문에 발생하는 현상이다. <br>

# 자주 발생하는 실수
아래는 클로저를 사용할 때 자주 발생할 수 있는 실수들이다.

```
var funcs = [];

for (var i = 0; i < 3; i++) {
    funcs[i] = function () { return i; };
}

for (var j = 0; j < fucns.length; j++) {
    console.log(funcs[j]());
}
```
위 예제에서 for문의 i는 var로 선언되었기 때문에 전역 변수 취급을 받는다. 때문에 funcs의 각 요소의 반환값이 0, 1, 2가 아닌 2로 같게 된다. 이를 해결하기 위해선 for문이 루프를 도는 시점의 스코프를 funcs의 요소들이 기억해야한다. <br>
그래서 IIFE(즉시실행함수)를 사용할 수도 있지만 ES6부터 추가된 let을 사용하면 된다. <br>
let은 함수 레벨 스코프가 아닌 블록 레벨 스코프이기 때문에 for문이 루프를 돌 때마다 새로운 렉시컬 환경이 생성되어 반환값이 제대로 나올수 있게 된다. <br>
그리고 또 다른 방법으로 함수형 프로그래밍 기법인 고차 함수를 사용하는 방법이 있다. 이 방법은 변수와 박본문의 사용을 억제할 수 있기 때문에 오류를 줄이고 가독성을 좋게 만든다. <br>






