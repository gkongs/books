---
description: 함수에 대해 알아봅시다.
---

# 함수
함수는 **일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이**다. <br>
함수는 **함수 정의**를 통해 생성하고 **함수 호출**을 통해 실행한다. <br>

# 함수를 사용하는 이유
함수를 사용하는 이유는 다음과 같다.
- 코드를 재사용하여 유지보수의 편의성을 높이고 실수를 줄여 신뢰성을 높일 수 있다.
- 함수는 함수 이름(식별자)를 붙일 수 있다. 때문에 함수로 코드를 나누고 알맞은 의미의 이름을 붙여준다면 가독성을 크게 높일 수 있다.

# 함수 리터럴
자바스크립트의 함수는 객체 타입이다. 따라서 함수도 객체처럼 함수 리터럴로 생성할 수 있다. <br>
그리고 함수 리터럴은 말 그대로 리터럴이므로 평가되어 값이 생성되며 값은 객체이다. **즉 함수는 객체이다.** <br>
함수는 객체지만 일반 객체와는 다르다. **일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.** 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다. <br>

# 함수 정의
함수 정의란 함수를 호출하기 이전에 매개변수, 실행할 문들, 반환할 값을 지정하는 것을 말한다. <br>
정의된 함수는 자바스크립트 엔진에 의해 평가 되어 함수 객체가 된다. 다음은 함수를 정의하는 방법들이다.
```
// 함수 선언문
function foo(x, y) {
    return x + y;
}

// 함수 표현식
var foo = function(x, y) {
    return x + y;
}

// Function 생성자 함수
var foo = new Function('x', 'y', 'return x + y');

// 화살표 함수 ES6
var foo = (x, y) => x + y;
``` 

> **함수는 정의** <br>
변수는 **선언**한다고 했지만 함수는 **정의**한다고 표현했다. 함수는 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 따라서 함수는 **정의**한다고 표현한다. <br>

# 함수 선언문
함수 선언문은 함수 리터럴과 형태가 동일하지만 **함수 이름을 생략할 수 없다.** <br>
함수 선언문은 **표현식이 아닌 문이다.** 따라서 크롬 개발자 도구의 콘솔에서 실행해보면 평가되지 않아 `undefined`가 출력된다. <br>
그런데 이상하게도 **표현식이 아닌 문**은 변수에 할당할 수 없는데 함수 선언문은 가능하다. <br>
```
var foo = function foo(x, y) {
    return x + y;
}
console.log(foo(2, 5)); // 7
```
이렇게 동작하는 이유는 **자바스크립트 엔진이 문맥에 따라 암묵적으로 함수 리터럴 표현식**으로 변경하기 때문이다. <br>
이렇게 함수 선언문과 함수 리터럴 표현식은 암묵적으로 변경도 되고 둘 다 함수를 생성하지만, 내부 동작에는 차이점이 있다. <br>
```
// 함수 선언문
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```
위 예제에서 단독으로 사용된 `foo`함수는 함수 선언문으로 해석되고 `그룹 연산자 ()`안의 `bar`함수는 함수 리터럴 표현식으로 해석된다. <br>
위 함수 중 `foo`는 호출할 수 있지만 `bar`는 호출되지 않는다. 왜그럴까? <br>
**함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.** 이 말은 즉, `bar`라는 식별자가 없다는 말이므로 함수 몸체 외부에서 `bar`라는 이름을 가지고 호출할 수 없다. <br>
하지만 함수 선언문으로 정의된 함수는 자바스크립트 엔진에 의하여 암묵적으로 함수 이름과 동일한 식별자가 생성되고 함수 객체를 할당 한다. <br>
따라서 함수 선언문은 호출이 될 수 있으며 함수는 함수 이름으로 호출하는 것이 아닌 함수 객체가 할당된 암묵적으로 생성된 **식별자**로 호출하는 것을 알 수 있다. <br>
결론적으로 함수 선언문은 내부적으로 함수 표현식처럼 변환해 함수 객체를 생성한다고 볼 수도 있다.(정확히 동일하게 동작하지는 않는다.)
