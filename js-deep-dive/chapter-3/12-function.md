---
description: 함수에 대해 알아봅시다.
---

# 함수
함수는 **일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이**다. <br>
함수는 **함수 정의**를 통해 생성하고 **함수 호출**을 통해 실행한다. <br>

# 함수를 사용하는 이유
함수를 사용하는 이유는 다음과 같다.
- 코드를 재사용하여 유지보수의 편의성을 높이고 실수를 줄여 신뢰성을 높일 수 있다.
- 함수는 함수 이름(식별자)를 붙일 수 있다. 때문에 함수로 코드를 나누고 알맞은 의미의 이름을 붙여준다면 가독성을 크게 높일 수 있다.

# 함수 리터럴
자바스크립트의 함수는 객체 타입이다. 따라서 함수도 객체처럼 함수 리터럴로 생성할 수 있다. <br>
그리고 함수 리터럴은 말 그대로 리터럴이므로 평가되어 값이 생성되며 값은 객체이다. **즉 함수는 객체이다.** <br>
함수는 객체지만 일반 객체와는 다르다. **일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.** 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다. <br>

# 함수 정의
함수 정의란 함수를 호출하기 이전에 매개변수, 실행할 문들, 반환할 값을 지정하는 것을 말한다. <br>
정의된 함수는 자바스크립트 엔진에 의해 평가 되어 함수 객체가 된다. 다음은 함수를 정의하는 방법들이다.
```
// 함수 선언문
function foo(x, y) {
    return x + y;
}

// 함수 표현식
var foo = function(x, y) {
    return x + y;
}

// Function 생성자 함수
var foo = new Function('x', 'y', 'return x + y');

// 화살표 함수 ES6
var foo = (x, y) => x + y;
``` 

> **함수는 정의** <br>
변수는 **선언**한다고 했지만 함수는 **정의**한다고 표현했다. 함수는 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 따라서 함수는 **정의**한다고 표현한다. <br>

# 함수 선언문
함수 선언문은 함수 리터럴과 형태가 동일하지만 **함수 이름을 생략할 수 없다.** <br>
함수 선언문은 **표현식이 아닌 문이다.** 따라서 크롬 개발자 도구의 콘솔에서 실행해보면 평가되지 않아 `undefined`가 출력된다. <br>
그런데 이상하게도 **표현식이 아닌 문**은 변수에 할당할 수 없는데 함수 선언문은 가능하다. <br>
```
var foo = function foo(x, y) {
    return x + y;
}
console.log(foo(2, 5)); // 7
```
이렇게 동작하는 이유는 **자바스크립트 엔진이 문맥에 따라 암묵적으로 함수 리터럴 표현식**으로 변경하기 때문이다. <br>
이렇게 함수 선언문과 함수 리터럴 표현식은 암묵적으로 변경도 되고 둘 다 함수를 생성하지만, 내부 동작에는 차이점이 있다. <br>
```
// 함수 선언문
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```
위 예제에서 단독으로 사용된 `foo`함수는 함수 선언문으로 해석되고 `그룹 연산자 ()`안의 `bar`함수는 함수 리터럴 표현식으로 해석된다. <br>
위 함수 중 `foo`는 호출할 수 있지만 `bar`는 호출되지 않는다. 왜그럴까? <br>
**함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.** 이 말은 즉, `bar`라는 식별자가 없다는 말이므로 함수 몸체 외부에서 `bar`라는 이름을 가지고 호출할 수 없다. <br>
하지만 함수 선언문으로 정의된 함수는 자바스크립트 엔진에 의하여 암묵적으로 함수 이름과 동일한 식별자가 생성되고 함수 객체를 할당 한다. <br>
따라서 함수 선언문은 호출이 될 수 있으며 함수는 함수 이름으로 호출하는 것이 아닌 함수 객체가 할당된 암묵적으로 생성된 **식별자**로 호출하는 것을 알 수 있다. <br>
결론적으로 함수 선언문은 내부적으로 함수 표현식처럼 변환해 함수 객체를 생성한다고 볼 수도 있다.(정확히 동일하게 동작하지는 않는다.) <br>

# 함수 표현식
앞서 말했듯 자바스크립트의 함수는 객체 타입의 값이다. 자바스크립트의 함수는 값처럼 변수에 할당 할 수도 있고 프로퍼티 값이 될 수도 잇으며 배열의 요소가 될 수도 있다. <br>
이처럼 값의 성질을 갖는 객체를 **일급 객체**라고 한다. **자바스크립트의 함수는 일급 객체다.** 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 것이다. <br>
함수 표현식은 함수 리터럴로 생선한 함수 객체를 변수에 할당하는 형태의 함수 정의를 말한다.
```
// 함수 표현식
var foo = function (x, y) {
    return x + y;
}
```
함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다. <br>

# 함수 생성 시점과 함수 호이스팅
함수도 변수처럼 런타임 이전에 먼저 실행되어 식별자를 생성하는 **호이스팅**을 한다. 그래서 코드 상 함수보다 위에서 함수를 실행해도 제대로 동작한다. <br>
하지만 변수 호이스팅과 함수 호이스팅은 동작이 약간 다른데, `var`를 통해 변수를 선언하면 `undefined`로 초기화 하지만 함수는 식별자를 생성하고 함수 객체로 초기화한다. <br>
반면 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 따라서 **함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현이다.** <br>
그러므로 **함수 표현식의 호이스팅은 함수 호이스팅이 아니라 변수 호이스팅이다.**

# 함수 호출

## 매개 변수와 인수
함수를 실행할 때 외부에서 내부에 필요한 값을 전달하기 위해 매개변수(인자)를 통해 인수를 전달한다. <br>
매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 동일하게 취급되어 일반 변수처럼 `undefined`로 초기화 된 후 인수가 순서대로 할당된다. <br>
함수는 인자와 인수의 개수가 일치하는지 체크하지 않는다. 따라서 매개변수보다 적게 인수를 전달해도 동작한다. <br>
매개변수보다 많이 전달했을 경우는 무시되는데 사라지는건 아니고 `arguments`객체에 프로퍼티로 보관된다. <br>

> **arguments object vs rest parameter** <br>
**arguments object와 rest parameter**는 모두 가변 인자를 다룰 때 사용한다. 하지만 약간의 차이점이 존재한다.<br>
**arguments object**는 **유사배열**이며 **모든 인수 값을 저장한다.**<br>
**rest parameter**는 **배열**이며 일반 매개변수들과 함께 사용할 수 있다. 때문에 특정 값은 이름을 정해 받고 나머지 값들은 `...others` 같은 이름으로 한 번에 받을 수 있다. 