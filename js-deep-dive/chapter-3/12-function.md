---
description: 함수에 대해 알아봅시다.
---

# 함수
함수는 **일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이**다. <br>
함수는 **함수 정의**를 통해 생성하고 **함수 호출**을 통해 실행한다. <br>

# 함수를 사용하는 이유
함수를 사용하는 이유는 다음과 같다.
- 코드를 재사용하여 유지보수의 편의성을 높이고 실수를 줄여 신뢰성을 높일 수 있다.
- 함수는 함수 이름(식별자)를 붙일 수 있다. 때문에 함수로 코드를 나누고 알맞은 의미의 이름을 붙여준다면 가독성을 크게 높일 수 있다.

# 함수 리터럴
자바스크립트의 함수는 객체 타입이다. 따라서 함수도 객체처럼 함수 리터럴로 생성할 수 있다. <br>
그리고 함수 리터럴은 말 그대로 리터럴이므로 평가되어 값이 생성되며 값은 객체이다. **즉 함수는 객체이다.** <br>
함수는 객체지만 일반 객체와는 다르다. **일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.** 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다. <br>

# 함수 정의
함수 정의란 함수를 호출하기 이전에 매개변수, 실행할 문들, 반환할 값을 지정하는 것을 말한다. <br>
정의된 함수는 자바스크립트 엔진에 의해 평가 되어 함수 객체가 된다. 다음은 함수를 정의하는 방법들이다.
```
// 함수 선언문
function foo(x, y) {
    return x + y;
}

// 함수 표현식
var foo = function(x, y) {
    return x + y;
}

// Function 생성자 함수
var foo = new Function('x', 'y', 'return x + y');

// 화살표 함수 ES6
var foo = (x, y) => x + y;
``` 

> **함수는 정의** <br>
변수는 **선언**한다고 했지만 함수는 **정의**한다고 표현했다. 함수는 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 따라서 함수는 **정의**한다고 표현한다. <br>

# 함수 선언문
함수 선언문은 함수 리터럴과 형태가 동일하지만 **함수 이름을 생략할 수 없다.** <br>
함수 선언문은 **표현식이 아닌 문이다.** 따라서 크롬 개발자 도구의 콘솔에서 실행해보면 평가되지 않아 `undefined`가 출력된다. <br>
그런데 이상하게도 **표현식이 아닌 문**은 변수에 할당할 수 없는데 함수 선언문은 가능하다. <br>
```
var foo = function foo(x, y) {
    return x + y;
}
console.log(foo(2, 5)); // 7
```
이렇게 동작하는 이유는 **자바스크립트 엔진이 문맥에 따라 암묵적으로 함수 리터럴 표현식**으로 변경하기 때문이다. <br>
이렇게 함수 선언문과 함수 리터럴 표현식은 암묵적으로 변경도 되고 둘 다 함수를 생성하지만, 내부 동작에는 차이점이 있다. <br>
```
// 함수 선언문
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```
위 예제에서 단독으로 사용된 `foo`함수는 함수 선언문으로 해석되고 `그룹 연산자 ()`안의 `bar`함수는 함수 리터럴 표현식으로 해석된다. <br>
위 함수 중 `foo`는 호출할 수 있지만 `bar`는 호출되지 않는다. 왜그럴까? <br>
**함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.** 이 말은 즉, `bar`라는 식별자가 없다는 말이므로 함수 몸체 외부에서 `bar`라는 이름을 가지고 호출할 수 없다. <br>
하지만 함수 선언문으로 정의된 함수는 자바스크립트 엔진에 의하여 암묵적으로 함수 이름과 동일한 식별자가 생성되고 함수 객체를 할당 한다. <br>
따라서 함수 선언문은 호출이 될 수 있으며 함수는 함수 이름으로 호출하는 것이 아닌 함수 객체가 할당된 암묵적으로 생성된 **식별자**로 호출하는 것을 알 수 있다. <br>
결론적으로 함수 선언문은 내부적으로 함수 표현식처럼 변환해 함수 객체를 생성한다고 볼 수도 있다.(정확히 동일하게 동작하지는 않는다.) <br>

# 함수 표현식
앞서 말했듯 자바스크립트의 함수는 객체 타입의 값이다. 자바스크립트의 함수는 값처럼 변수에 할당 할 수도 있고 프로퍼티 값이 될 수도 잇으며 배열의 요소가 될 수도 있다. <br>
이처럼 값의 성질을 갖는 객체를 **일급 객체**라고 한다. **자바스크립트의 함수는 일급 객체다.** 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 것이다. <br>
함수 표현식은 함수 리터럴로 생선한 함수 객체를 변수에 할당하는 형태의 함수 정의를 말한다.
```
// 함수 표현식
var foo = function (x, y) {
    return x + y;
}
```
함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다. <br>

# 함수 생성 시점과 함수 호이스팅
함수도 변수처럼 런타임 이전에 먼저 실행되어 식별자를 생성하는 **호이스팅**을 한다. 그래서 코드 상 함수보다 위에서 함수를 실행해도 제대로 동작한다. <br>
하지만 변수 호이스팅과 함수 호이스팅은 동작이 약간 다른데, `var`를 통해 변수를 선언하면 `undefined`로 초기화 하지만 함수는 식별자를 생성하고 함수 객체로 초기화한다. <br>
반면 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 따라서 **함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현이다.** <br>
그러므로 **함수 표현식의 호이스팅은 함수 호이스팅이 아니라 변수 호이스팅이다.**

# 함수 호출

## 매개 변수와 인수
함수를 실행할 때 외부에서 내부에 필요한 값을 전달하기 위해 매개변수(인자)를 통해 인수를 전달한다. <br>
매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 동일하게 취급되어 일반 변수처럼 `undefined`로 초기화 된 후 인수가 순서대로 할당된다. <br>
함수는 인자와 인수의 개수가 일치하는지 체크하지 않는다. 따라서 매개변수보다 적게 인수를 전달해도 동작한다. <br>
매개변수보다 많이 전달했을 경우는 무시되는데 사라지는건 아니고 `arguments`객체에 프로퍼티로 보관된다. <br>

> **arguments object vs rest parameter** <br>
**arguments object와 rest parameter**는 모두 가변 인자를 다룰 때 사용한다. 하지만 약간의 차이점이 존재한다.<br>
**arguments object**는 **유사배열**이며 **모든 인수 값을 저장한다.**<br>
**rest parameter**는 **배열**이며 일반 매개변수들과 함께 사용할 수 있다. 때문에 특정 값은 이름을 정해 받고 나머지 값들은 `...others` 같은 이름으로 한 번에 받을 수 있다. 

# 참조에 의한 전달과 외부 상태의 변경
함수로 전달되는 인수 중 객체 타입의 값은 함수 내부에서 값을 변경하더라도 **참조에 의한 전달**이기 때문에 외부의 객체 값이 변경되는 **부수 효과**가 발생할 수 있다. <br>
이러한 **부수효과**는 객체가 어디서 변경되었는지 추적하기 어렵게 하며 프로그래밍의 복잡성을 증가시키는 원인이 된다. <br>
때문에 이를 해결하기 위해서 객체의 변경을 추적하는 옵저버 패턴 등을 사용하기도 하고 아예 객체를 불변 객체로 만들어 사용하기도 한다. <br>

# 다양한 함수의 형태

## 즉시 실행 함수
즉시 실행 함수는 말 그대로 즉시 실행하는 함수이며 함수 이름을 적는 기명 즉시 실행 함수라도 다시 사용할 수 없다. 왜냐하면 즉시 실행 함수는 일반적으로 `() 그룹 연산자`로 감싸는 형태로 사용하는데 앞서 이야기 했던 것처럼 자바스크립트 엔진은 함수 리터럴을 문맥에 맞게 선언문 또는 리터럴 표현식으로 하는데 그룹 연산자 안에 들어 있다면 평가할 수 있는 식 즉, 리터럴 표현식으로 해석하기 때문이다. <br>
```
// 일반적인 즉시 실행 함수. ()로 감싸고 함수 호출 연산자인 ()를 붙여준다.
(function () {
    // ...
}());
```
즉시 실행 함수 내에 코드를 모아두면 변수나 함수 이름의 충돌을 방지할 수 있다.
```
var foo = (function () {
    return 'foo';
}());

console.log(res); // foo
```

## 중첩 함수
함수 내부에 정의된 함수를 **중첩 함수** 또는 **내부 함수**라고 하며, 이를 포함하는 함수를 **외부 함수**라고 한다. <br>
중첩 함수는 외부 함수 내에서만 호출할 수 잇으며 일반적으로 외부 함수를 돕는 헬퍼 함수의 역할을 한다. <br>

## 콜백 함수
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수**라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 **고차 함수**라고 한다. <br>
매개변수를 통해 함수를 전달 받거나 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍 패러다임에서 **고차 함수**라고 한다. <br>
콜백 함수도 고차 함수의 **헬퍼 함수**라고 할 수 있지만 앞서 나온 중첩 함수와는 다르게 고정되어 있는 것이 아니라 외부에서 주입하기 때문에 **자유롭게 교체할 수 있다는 장점**이 있다. <br>
**고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.** 즉, 콜백 함수는 고차 함수에 의해 호출되며(모두가 그렇진 않다.) 이 때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다. 때문에 콜백 함수를 전달할 때 함수 자체를 전달 해야 한다. <br>

## 순수 함수와 비순수 함수
외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 **순수 함수**라고 하며 이와 반대로 외부 상태에 의존하거나 외부 상태를 변경하는 함수를 **비순수 함수라고 한다.** <br>
그리고 순수함수를 통해 최대한 부수 효과를 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 **함수형 프로그래밍**이라 한다. <br>
외부 상태에는 전역 변수, 서버 데이터, 파일, Console, DOM 등이 있고 만약 외부 상태에 의존하지 않고 내부 상태에만 의존한다 하더라도 내부 상태가 호출될 때마다 변화하는 값(예: 현재시간)이라면 순수 함수가 아니다. <br>
순수 함수는 최소 하나 이상의 인수를 전달받는다. 인수를 전달받지 않으면 순수 함수는 언제나 동일한 값을 반환하므로 상수와 다른게 없다. 따라서 최소 하나 이상의 인수를 전달 받아야한다. <br>
또한 인수를 변경하지 않는 것이 기본이다. 다시 말해 **순수 함수는 인수의 불변성을 유지한다.**
