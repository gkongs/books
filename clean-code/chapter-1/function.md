---
description: 함수를 클린하게 만드는 방법들을 알아봅시다.
---

# 작게 만들어라 그리고 한 가지만 해라
함수를 만드는 첫째 규칙은 **작게!** 둘째 규칙은 **더 작게!**이며 둘째 규칙은 한 가지만 하도록 만들라는 것이다. <br>
여기서 둘째 규칙인 한 가지만 하라는 말은 솔직히 무엇이 한 가지만 하는 것인지 알기 어렵다. <br>
책에서는 함수가 의미를 유지하면서 더 이상 나눌 수 없는 상태라면 한 가지만을 하는 상태라고 말한다. 또한 함수 내에서 섹션을 나눌 수 있다면 이는 한 가지 일을 하는게 아니므로 섹션이 나눠지지 않을 때 까지 함수를 쪼개길 권장한다. <br>

# 함수 당 추상화 수준은 하나로
- 추상화 수준 관련 https://onestone-dev.tistory.com/3  <br>

추상화 수준을 섞으면 한 가지일을 하는 함수를 작성하기 힘드므로 추상화 수준이 하나인 함수를 구현하려 노력해야한다. <br>
그러나 이는 쉽지 않은 일이다. 때문에 책에서는 내려가기 규칙이라는 방법을 제시하고 있다. <br>

> **내려가기 규칙**은 코드가 위에서 아래로 읽히므로 추상화 수준이 높은 순서 부터 낮은 순서대로 함수를 배치하는 규칙을 말한다.

# Switch 문
switch문, if else 문은 작게 만들기 어렵다. 또한 함수에 사용되었을 때 분기문이 가지는 의미상 한 가지를 하는 함수가 아니게 되어 버린다. <br>
이 문제를 해결하는 방법은 swicth문을 추상 팩토리에 꽁꽁 숨기는 방식을 사용하는 것이다. <br>
이렇게 되면 함수 규칙을 지킬뿐만아니라 **SRP, OCP** 등의 규칙도 지킬 수 있다.<br>

# 서술적인 이름을 사용하라
이름은 짧을 수록 좋지만 단순히 **짧기 위해서** 이름을 지으면 안된다. 그렇게 되면 함수를 제대로 표현하지 못하는 이름이 된다. <br>
그럴빠엔 차라리 이름은 조금 길지라도 함수의 의미를 정확하게 파악할 수 있는 서술적인 이름을 사용하는 것이 좋다. <br>

# 함수 인수
함수의 인수 갯수는 중요하다. 0개가 가장 이상적이고 그 다음은 1개(단항), 다음은 2개(이항)이다. <br>
그보다 많은 삼항(3개)는 가능한 피해야 하며, 다항(4개 이상)은 특별한 경우가 아니면 사용하지 않는다. <br>
코드를 읽는 사람에게는 인수가 있는 함수보다 없는 함수가 읽기 좋다. <br>
```
includeSetupPageInto(new PageContent) // bad
includeSetupPageInto() // good
```
위 예제처럼 인수가 없는게 이해하기 더 좋다. 그리고 테스트 관점에서도 인수가 많아지면 인수만큼 테스트 케이스가 늘어나 테스트하기 힘들어 진다. <br>

### 많이 쓰는 단항 형식
함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다. 하나는 인수에 질문을 던지는 경우다. `boolean fileExists('MyFile')`이 좋은 예다. <br>
다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다. `InputStream fileOpen('MyFile')`은 String 형의 파일 이름을 InputStream으로 반환한다. <br>
그리고 드물게 사용하지만 이벤트 함수도 대표적으로 단항을 받는 형식 중 하나이다. <br> 
이벤트는 입력은 있지만 출력은 없으며 시스템의 상태를 변경하기에 이벤트라는 사실이 코드에 명확히 드러나야한다. <br>
이외의 경우가 아니라면 가급적 단항 함수를 피하는게 좋으며, 변환 함수는 변환 결과를 반환값으로 돌려주도록 작성하는 것이 좋다. <br>

### 플래그 인수
플래그 인수는 이미 "이 함수는 여러가지 일을 합니다."라고 적어 놓은 것과 마찬가지다. 따라서 최대한 사용하지말고 함수를 나누는게 좋다. <br>

### 이항 함수
이항 함수가 사용되는 경우는 인수가 자연적인 순서가 있는 경우이다. 좋은 예로 `point`가 있다. `point`는 일반적으로 좌표 x, y(0, 0)을 가지는 자연적인 순서가 있다. <br>

### 인수 객체
인수가 여러 개 필요할 때 독자적인 클래스 변수롤 선언하는 방법이 있다. 단순히 인수를 묶은 것이라 생각 할 수 있지만, 묶으면서 이름을 지정해주며 인수의 순서를 틀리게 작성하는 경우도 없게 만들어 준다. <br>

### 함수와 인수의 이름
함수와 인수는 동사/명사 쌍을 이뤄 만드는 것이 좋다. `write(name)` 같이 말이다.
이렇게 하면 한 번에 함수를 파악할 수 있다. 여기서 더 나아가 `writeField(name)` 같은 이름이면 더욱 좋다. <br>
그리고 함수 이름을 지을 때 인수의 순서를 기억할 필요 없이 짓는 것도 나름의 방법이다. `assertEquals(expected, actual)`과 `assertExpectedEqualsActual(expected, actual)` 을 비교해보면 후자가 이름은 길지만 인수의 순서를 기억할 필요가 없는 장점이 있다. <br>

# 부수 효과를 일으키지 마라
부수 효과 또한 함수가 한 가지 일을 하는 규칙에 위배된다.

### 출력 인수
출력 인수는 가급적 피하는게 좋으며 만약 함수에서 상태를 변경해야 한다면 속한 객체의 상태를 변경하는게 좋다. <br>

# 명령과 조회를 분리하라
함수는 뭔가를 수행하거나 답하거나 둘 중 하나만 해야 한다. 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나다. <br>
