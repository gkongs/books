---
description: 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 알아봅시다.
---

# 외부 코드 사용하기
인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다. 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 그만큼 구매자 있을 것이기 떄문이다. <br>
하지만 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다. <br>

```
Map sensoers = new HashMap();
Sensor s = (Sensor)sensors.get(sensorId);
```
위 예제는 Map 패키지를 외부에서 가져와 사용할 때 `Sensor`라는 객체를 담으려면 작성해야 하는 코드다. <br>
이를 개선하려면 다음과 같이 제네릭스를 사용할 수 있다. <br>
```
Map<String, Sensor> sensors = new HashMap<Sensor>();

Sensor s = sensors.get(sensorId);
```

하지만 위 방법도 `Map<String, Sensor>`가 사용자에게 필요하지 않은 기능까지 제공한다는 문제는 해결하지 못한다. <br>

다음은 좀 더 개선된 코드 예제이다. 
```
public class Sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
}
```
경계 인터페이스인 Map을 Sensors 클래스 안으로 숨긴다. 이렇게 하면 Sensors 클래스는 프로그램에 필요한 인터페이스만을 제공하여 코드를 이해하기 쉽고 오용하긴 어렵게 된다. <br>
물론 항상 이렇게 캡슐화 할 필요는 없다. <br>

# 경계 살피고 익히기
외부 패키지 테스트는 우리의 책임이 아니지만 우리를 위해 우리가 사용할 코드를 테스트하는 건 바람직한 행동이다. <br>
외부 코드를 익히기는 어렵고 외부 코드를 통합하기도 어렵다. 따라서 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 **학습 테스트** 방법을 사용하는 것도 좋은 방법이다. <br>

**학습 테스트**는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다. 학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다. <br>

# 학습 테스트는 공짜 이상이다
학습 테스트는 필요한 지식만 확보하는 손쉬운 방법이며 이해도를 높여주는 정확한 실험이다. <br>
학습 테스트는 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다. 학습 테스트는 패키지가 예상대로 도는지 검증한다. <br>
학습 테스트가 필요하든 그렇지 않든, **실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다.** 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다. <br>

# 마무리
끝으로 외부 코드에 의존하기보단 항상 통제가 가능한 우리 코드에 의존하는 편이 좋다. 그러므로 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. <br>
앞의 `Map`예제처럼 새로운 클래스로 경계를 감싸거나 아니면 `ADAPTER 패턴`을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하는게 좋다. 어느 방법이든 코드 가독성과 경계 인터페이스를 사용하는 일관성이 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다. <br>

